{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://github.com/freebsd/freebsd-src/blob/main/lib/msun/src/s_sinpif.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar kernelCosf = require( '@stdlib/math-base-special-kernel-cosf' );\nvar kernelSinf = require( '@stdlib/math-base-special-kernel-sinf' );\nvar f32 = require( '@stdlib/number-float64-base-to-float32' );\nvar float32ToUint32 = require( '@stdlib/number-float32-base-to-uint32' );\nvar toWordf = require( '@stdlib/number-float32-base-to-word' );\nvar fromWordf = require( '@stdlib/number-float32-base-from-word' );\nvar FLOAT32_ABS_MASK = require( '@stdlib/constants-float32-abs-mask' );\nvar FLOAT32_EXPONENT_MASK = require( '@stdlib/constants-float32-exponent-mask' );\nvar FLOAT32_EXPONENT_BIAS = require( '@stdlib/constants-float32-exponent-bias' );\nvar FLOAT32_NUM_SIGNIFICAND_BITS = require( '@stdlib/constants-float32-num-significand-bits' );\nvar FLOAT32_SIGNIFICAND_MASK = require( '@stdlib/constants-float32-significand-mask' );\nvar PI = require( '@stdlib/constants-float64-pi' );\n\n\n// VARIABLES //\n\n// 1 => 0 01111111 00000000000000000000000 => 0x3f800000 = 1065353216\nvar ONE_WORD = 0x3f800000 >>> 0; // asm type annotation\n\n// 1/2 = 0.5 => 0 01111110 00000000000000000000000 => 0x3f000000 = 1056964608\nvar HALF_WORD = 0x3f000000 >>> 0; // asm type annotation\n\n// 1/4 = 0.25 => 0 01111101 00000000000000000000000 => 0x3e800000 = 1048576000\nvar QUARTER_WORD = 0x3e800000 >>> 0; // asm type annotation\n\n// 3/4 = 0.75 => 0 01111110 10000000000000000000000 => 0x3f400000 = 1061158912\nvar THREE_QUARTER_WORD = 0x3f400000 >>> 0; // asm type annotation\n\n// 2^-14 = 0.00006103515625 => 0 01110001 00000000000000000000000 => 0x38800000 = 947912704\nvar SMALL_WORD = 0x38800000 >>> 0; // asm type annotation\n\n// 2^23 = 8388608 => 0 10010110 00000000000000000000000 => 0x4b000000 = 1258291200\nvar TWO_23_WORD = 0x4b000000 >>> 0; // asm type annotation\n\n// 2^24 = 16777216 => 0 00000010 00000000000000000000000 => 0x4b800000 = 1266679808\nvar TWO_24_WORD = 0x4b800000 >>> 0; // asm type annotation\n\n// Mask for extracting the exponent bits of a 32-bit float:\nvar FLOAT32_EXPONENT_FIELD_MASK = 0xff >>> 0; // asm type annotation\n\nvar NEG_ONE = f32( -1.0 );\nvar ZERO = f32( 0.0 );\nvar HALF = f32( 0.5 );\nvar ONE = f32( 1.0 );\n\n\n// MAIN //\n\n/**\n* Computes the value of `cos(\u03C0x)` in single-precision floating-point format.\n*\n* ## Notes\n*\n* -   The function computes `cos(\u03C0x)` more accurately than the obvious approach, especially for large `x`.\n*\n* @param {number} x - input value\n* @returns {number} function value\n*\n* @example\n* var y = cospif( 0.0 );\n* // returns 1.0\n*\n* @example\n* var y = cospif( 0.5 );\n* // returns 0.0\n*\n* @example\n* var y = cospif( 0.1 );\n* // returns ~0.951\n*\n* @example\n* var y = cospif( NaN );\n* // returns NaN\n*/\nfunction cospif( x ) {\n\tvar hx;\n\tvar ix;\n\tvar j0;\n\tvar ax;\n\tvar c;\n\n\tx = f32( x );\n\thx = toWordf( f32( x ) );\n\tix = (hx & FLOAT32_ABS_MASK) >>> 0; // asm type annotation\n\tax = fromWordf( ix ); // asm type annotation\n\n\t// Case: |x| < 1\n\tif ( ix < ONE_WORD ) {\n\t\t// Case: |x| < 0.25\n\t\tif ( ix < QUARTER_WORD ) {\n\t\t\t// Case: |x| < 2^-14\n\t\t\tif ( ix < SMALL_WORD ) {\n\t\t\t\tif ( x === 0.0 ) {\n\t\t\t\t\treturn ONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn kernelCosf( PI * f32( ax ) );\n\t\t}\n\t\t// Case: |x| < 0.5\n\t\tif ( ix < HALF_WORD ) {\n\t\t\tc = kernelSinf( PI * f32( HALF - ax ) );\n\t\t} else if ( ix < THREE_QUARTER_WORD ) { // Case: |x| < 0.75\n\t\t\tif ( ix === HALF_WORD ) {\n\t\t\t\treturn ZERO;\n\t\t\t}\n\t\t\tc = f32( -kernelSinf( PI * f32( ax - HALF ) ) );\n\t\t} else {\n\t\t\tc = f32( -kernelCosf( PI * f32( ONE - ax ) ) );\n\t\t}\n\t\treturn c;\n\t}\n\t// Case: 1 <= |x| < 2^23\n\tif ( ix < TWO_23_WORD ) {\n\t\t// Fast floor by bitwise manipulation:\n\t\tj0 = ( ( ix >> FLOAT32_NUM_SIGNIFICAND_BITS ) & FLOAT32_EXPONENT_FIELD_MASK ) - FLOAT32_EXPONENT_BIAS; // eslint-disable-line max-len\n\t\tix &= ~( FLOAT32_SIGNIFICAND_MASK >> j0 );\n\t\tx = fromWordf( ix );\n\n\t\tax = f32( ax - x );\n\t\tix = toWordf( ax );\n\n\t\t// Case: |x| < 0.5\n\t\tif ( ix < HALF_WORD ) {\n\t\t\t// Case: |x| < 0.25\n\t\t\tif ( ix < QUARTER_WORD ) {\n\t\t\t\tc = ( ix === 0 ) ? ONE : kernelCosf( PI * f32( ax ) );\n\t\t\t} else {\n\t\t\t\tc = kernelSinf( PI * f32( HALF - ax ) );\n\t\t\t}\n\t\t} else if ( ix < THREE_QUARTER_WORD ) { // Case: |x| < 0.75\n\t\t\tif ( ix === HALF_WORD ) {\n\t\t\t\treturn ZERO;\n\t\t\t}\n\t\t\tc = f32( -kernelSinf( PI * f32( ax - HALF ) ) );\n\t\t} else {\n\t\t\tc = f32( -kernelCosf( PI * f32( ONE - ax ) ) );\n\t\t}\n\t\tj0 = float32ToUint32( x );\n\t\treturn ( j0 & 1 ) ? -c : c;\n\t}\n\t// Case: x is NaN or infinity\n\tif ( ix >= FLOAT32_EXPONENT_MASK ) {\n\t\treturn NaN;\n\t}\n\t// Case: 2^23 <= |x| < 2^24 - determine if x is an even or odd integer to return +1 or -1.\n\tif ( ix < TWO_24_WORD ) {\n\t\treturn ( ix & 1 ) ? NEG_ONE : ONE;\n\t}\n\t// Case: |x| >= 2^24 is always an even integer, so return +1.\n\treturn ONE;\n}\n\n\n// EXPORTS //\n\nmodule.exports = cospif;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute `cos(\u03C0x)` in single-precision floating-point format.\n*\n* @module @stdlib/math-base-special-cospif\n*\n* @example\n* var cospif = require( '@stdlib/math-base-special-cospif' );\n*\n* var y = cospif( 0.0 );\n* // returns 1.0\n*\n* y = cospif( 0.5 );\n* // returns 0.0\n*\n* y = cospif( 0.1 );\n* // returns ~0.951\n*\n* y = cospif( NaN );\n* // returns NaN\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAoCA,IAAIC,EAAa,QAAS,uCAAwC,EAC9DC,EAAa,QAAS,uCAAwC,EAC9DC,EAAM,QAAS,wCAAyC,EACxDC,EAAkB,QAAS,uCAAwC,EACnEC,EAAU,QAAS,qCAAsC,EACzDC,EAAY,QAAS,uCAAwC,EAC7DC,EAAmB,QAAS,oCAAqC,EACjEC,EAAwB,QAAS,yCAA0C,EAC3EC,EAAwB,QAAS,yCAA0C,EAC3EC,EAA+B,QAAS,gDAAiD,EACzFC,EAA2B,QAAS,4CAA6C,EACjFC,EAAK,QAAS,8BAA+B,EAM7CC,EAAW,WAGXC,EAAY,WAGZC,EAAe,UAGfC,EAAqB,WAGrBC,EAAa,UAGbC,EAAc,WAGdC,EAAc,WAGdC,EAA8B,IAE9BC,EAAUlB,EAAK,EAAK,EACpBmB,EAAOnB,EAAK,CAAI,EAChBoB,EAAOpB,EAAK,EAAI,EAChBqB,EAAMrB,EAAK,CAAI,EA+BnB,SAASsB,EAAQC,EAAI,CACpB,IAAIC,EACAC,EACAC,EACAC,EACAC,EAQJ,GANAL,EAAIvB,EAAKuB,CAAE,EACXC,EAAKtB,EAASF,EAAKuB,CAAE,CAAE,EACvBE,GAAMD,EAAKpB,KAAsB,EACjCuB,EAAKxB,EAAWsB,CAAG,EAGdA,EAAKf,EAAW,CAEpB,GAAKe,EAAKb,EAET,OAAKa,EAAKX,GACJS,IAAM,EACHF,EAGFvB,EAAYW,EAAKT,EAAK2B,CAAG,CAAE,EAGnC,GAAKF,EAAKd,EACTiB,EAAI7B,EAAYU,EAAKT,EAAKoB,EAAOO,CAAG,CAAE,UAC3BF,EAAKZ,EAAqB,CACrC,GAAKY,IAAOd,EACX,OAAOQ,EAERS,EAAI5B,EAAK,CAACD,EAAYU,EAAKT,EAAK2B,EAAKP,CAAK,CAAE,CAAE,CAC/C,MACCQ,EAAI5B,EAAK,CAACF,EAAYW,EAAKT,EAAKqB,EAAMM,CAAG,CAAE,CAAE,EAE9C,OAAOC,CACR,CAEA,GAAKH,EAAKV,EAAc,CAUvB,GARAW,GAASD,GAAMlB,EAAiCU,GAAgCX,EAChFmB,GAAM,EAAGjB,GAA4BkB,GACrCH,EAAIpB,EAAWsB,CAAG,EAElBE,EAAK3B,EAAK2B,EAAKJ,CAAE,EACjBE,EAAKvB,EAASyB,CAAG,EAGZF,EAAKd,EAEJc,EAAKb,EACTgB,EAAMH,IAAO,EAAMJ,EAAMvB,EAAYW,EAAKT,EAAK2B,CAAG,CAAE,EAEpDC,EAAI7B,EAAYU,EAAKT,EAAKoB,EAAOO,CAAG,CAAE,UAE5BF,EAAKZ,EAAqB,CACrC,GAAKY,IAAOd,EACX,OAAOQ,EAERS,EAAI5B,EAAK,CAACD,EAAYU,EAAKT,EAAK2B,EAAKP,CAAK,CAAE,CAAE,CAC/C,MACCQ,EAAI5B,EAAK,CAACF,EAAYW,EAAKT,EAAKqB,EAAMM,CAAG,CAAE,CAAE,EAE9C,OAAAD,EAAKzB,EAAiBsB,CAAE,EACfG,EAAK,EAAM,CAACE,EAAIA,CAC1B,CAEA,OAAKH,GAAMpB,EACH,IAGHoB,EAAKT,GACAS,EAAK,EAAMP,EAGdG,CACR,CAKAxB,EAAO,QAAUyB,ICpJjB,IAAIO,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "kernelCosf", "kernelSinf", "f32", "float32ToUint32", "toWordf", "fromWordf", "FLOAT32_ABS_MASK", "FLOAT32_EXPONENT_MASK", "FLOAT32_EXPONENT_BIAS", "FLOAT32_NUM_SIGNIFICAND_BITS", "FLOAT32_SIGNIFICAND_MASK", "PI", "ONE_WORD", "HALF_WORD", "QUARTER_WORD", "THREE_QUARTER_WORD", "SMALL_WORD", "TWO_23_WORD", "TWO_24_WORD", "FLOAT32_EXPONENT_FIELD_MASK", "NEG_ONE", "ZERO", "HALF", "ONE", "cospif", "x", "hx", "ix", "j0", "ax", "c", "main"]
}
