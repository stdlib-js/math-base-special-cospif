{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://github.com/freebsd/freebsd-src/blob/main/lib/msun/src/s_sinpif.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport kernelCosf from '@stdlib/math-base-special-kernel-cosf';\nimport kernelSinf from '@stdlib/math-base-special-kernel-sinf';\nimport f32 from '@stdlib/number-float64-base-to-float32';\nimport float32ToUint32 from '@stdlib/number-float32-base-to-uint32';\nimport toWordf from '@stdlib/number-float32-base-to-word';\nimport fromWordf from '@stdlib/number-float32-base-from-word';\nimport FLOAT32_ABS_MASK from '@stdlib/constants-float32-abs-mask';\nimport FLOAT32_EXPONENT_MASK from '@stdlib/constants-float32-exponent-mask';\nimport FLOAT32_EXPONENT_BIAS from '@stdlib/constants-float32-exponent-bias';\nimport FLOAT32_NUM_SIGNIFICAND_BITS from '@stdlib/constants-float32-num-significand-bits';\nimport FLOAT32_SIGNIFICAND_MASK from '@stdlib/constants-float32-significand-mask';\nimport PI from '@stdlib/constants-float64-pi';\n\n\n// VARIABLES //\n\n// 1 => 0 01111111 00000000000000000000000 => 0x3f800000 = 1065353216\nvar ONE_WORD = 0x3f800000 >>> 0; // asm type annotation\n\n// 1/2 = 0.5 => 0 01111110 00000000000000000000000 => 0x3f000000 = 1056964608\nvar HALF_WORD = 0x3f000000 >>> 0; // asm type annotation\n\n// 1/4 = 0.25 => 0 01111101 00000000000000000000000 => 0x3e800000 = 1048576000\nvar QUARTER_WORD = 0x3e800000 >>> 0; // asm type annotation\n\n// 3/4 = 0.75 => 0 01111110 10000000000000000000000 => 0x3f400000 = 1061158912\nvar THREE_QUARTER_WORD = 0x3f400000 >>> 0; // asm type annotation\n\n// 2^-14 = 0.00006103515625 => 0 01110001 00000000000000000000000 => 0x38800000 = 947912704\nvar SMALL_WORD = 0x38800000 >>> 0; // asm type annotation\n\n// 2^23 = 8388608 => 0 10010110 00000000000000000000000 => 0x4b000000 = 1258291200\nvar TWO_23_WORD = 0x4b000000 >>> 0; // asm type annotation\n\n// 2^24 = 16777216 => 0 00000010 00000000000000000000000 => 0x4b800000 = 1266679808\nvar TWO_24_WORD = 0x4b800000 >>> 0; // asm type annotation\n\n// Mask for extracting the exponent bits of a 32-bit float:\nvar FLOAT32_EXPONENT_FIELD_MASK = 0xff >>> 0; // asm type annotation\n\nvar NEG_ONE = f32( -1.0 );\nvar ZERO = f32( 0.0 );\nvar HALF = f32( 0.5 );\nvar ONE = f32( 1.0 );\n\n\n// MAIN //\n\n/**\n* Computes the value of `cos(πx)` in single-precision floating-point format.\n*\n* ## Notes\n*\n* -   The function computes `cos(πx)` more accurately than the obvious approach, especially for large `x`.\n*\n* @param {number} x - input value\n* @returns {number} function value\n*\n* @example\n* var y = cospif( 0.0 );\n* // returns 1.0\n*\n* @example\n* var y = cospif( 0.5 );\n* // returns 0.0\n*\n* @example\n* var y = cospif( 0.1 );\n* // returns ~0.951\n*\n* @example\n* var y = cospif( NaN );\n* // returns NaN\n*/\nfunction cospif( x ) {\n\tvar hx;\n\tvar ix;\n\tvar j0;\n\tvar ax;\n\tvar c;\n\n\tx = f32( x );\n\thx = toWordf( f32( x ) );\n\tix = (hx & FLOAT32_ABS_MASK) >>> 0; // asm type annotation\n\tax = fromWordf( ix ); // asm type annotation\n\n\t// Case: |x| < 1\n\tif ( ix < ONE_WORD ) {\n\t\t// Case: |x| < 0.25\n\t\tif ( ix < QUARTER_WORD ) {\n\t\t\t// Case: |x| < 2^-14\n\t\t\tif ( ix < SMALL_WORD ) {\n\t\t\t\tif ( x === 0.0 ) {\n\t\t\t\t\treturn ONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn kernelCosf( PI * f32( ax ) );\n\t\t}\n\t\t// Case: |x| < 0.5\n\t\tif ( ix < HALF_WORD ) {\n\t\t\tc = kernelSinf( PI * f32( HALF - ax ) );\n\t\t} else if ( ix < THREE_QUARTER_WORD ) { // Case: |x| < 0.75\n\t\t\tif ( ix === HALF_WORD ) {\n\t\t\t\treturn ZERO;\n\t\t\t}\n\t\t\tc = f32( -kernelSinf( PI * f32( ax - HALF ) ) );\n\t\t} else {\n\t\t\tc = f32( -kernelCosf( PI * f32( ONE - ax ) ) );\n\t\t}\n\t\treturn c;\n\t}\n\t// Case: 1 <= |x| < 2^23\n\tif ( ix < TWO_23_WORD ) {\n\t\t// Fast floor by bitwise manipulation:\n\t\tj0 = ( ( ix >> FLOAT32_NUM_SIGNIFICAND_BITS ) & FLOAT32_EXPONENT_FIELD_MASK ) - FLOAT32_EXPONENT_BIAS; // eslint-disable-line max-len\n\t\tix &= ~( FLOAT32_SIGNIFICAND_MASK >> j0 );\n\t\tx = fromWordf( ix );\n\n\t\tax = f32( ax - x );\n\t\tix = toWordf( ax );\n\n\t\t// Case: |x| < 0.5\n\t\tif ( ix < HALF_WORD ) {\n\t\t\t// Case: |x| < 0.25\n\t\t\tif ( ix < QUARTER_WORD ) {\n\t\t\t\tc = ( ix === 0 ) ? ONE : kernelCosf( PI * f32( ax ) );\n\t\t\t} else {\n\t\t\t\tc = kernelSinf( PI * f32( HALF - ax ) );\n\t\t\t}\n\t\t} else if ( ix < THREE_QUARTER_WORD ) { // Case: |x| < 0.75\n\t\t\tif ( ix === HALF_WORD ) {\n\t\t\t\treturn ZERO;\n\t\t\t}\n\t\t\tc = f32( -kernelSinf( PI * f32( ax - HALF ) ) );\n\t\t} else {\n\t\t\tc = f32( -kernelCosf( PI * f32( ONE - ax ) ) );\n\t\t}\n\t\tj0 = float32ToUint32( x );\n\t\treturn ( j0 & 1 ) ? -c : c;\n\t}\n\t// Case: x is NaN or infinity\n\tif ( ix >= FLOAT32_EXPONENT_MASK ) {\n\t\treturn NaN;\n\t}\n\t// Case: 2^23 <= |x| < 2^24 - determine if x is an even or odd integer to return +1 or -1.\n\tif ( ix < TWO_24_WORD ) {\n\t\treturn ( ix & 1 ) ? NEG_ONE : ONE;\n\t}\n\t// Case: |x| >= 2^24 is always an even integer, so return +1.\n\treturn ONE;\n}\n\n\n// EXPORTS //\n\nexport default cospif;\n"],"names":["HALF_WORD","QUARTER_WORD","THREE_QUARTER_WORD","NEG_ONE","f32","ZERO","HALF","ONE","cospif","x","hx","ix","ax","c","toWordf","fromWordf","FLOAT32_ABS_MASK","kernelCosf","PI","kernelSinf","FLOAT32_SIGNIFICAND_MASK","FLOAT32_NUM_SIGNIFICAND_BITS","FLOAT32_EXPONENT_BIAS","float32ToUint32","FLOAT32_EXPONENT_MASK","NaN"],"mappings":";;utCAqDA,IAGIA,EAAY,WAGZC,EAAe,UAGfC,EAAqB,WAcrBC,EAAUC,GAAM,GAChBC,EAAOD,EAAK,GACZE,EAAOF,EAAK,IACZG,EAAMH,EAAK,GA+Bf,SAASI,EAAQC,GAChB,IAAIC,EACAC,EAEAC,EACAC,EAQJ,GANAJ,EAAIL,EAAKK,GACTC,EAAKI,EAASV,EAAKK,IAEnBG,EAAKG,EADLJ,GAAMD,EAAKM,KAAsB,GAI5BL,EAtES,WAsEO,CAEpB,GAAKA,EAAKV,EAET,OAAKU,EA9DS,WA+DF,IAANF,EACGF,EAGFU,EAAYC,EAAKd,EAAKQ,IAG9B,GAAKD,EAAKX,EACTa,EAAIM,EAAYD,EAAKd,EAAKE,EAAOM,SAC3B,GAAKD,EAAKT,EAAqB,CACrC,GAAKS,IAAOX,EACX,OAAOK,EAERQ,EAAIT,GAAMe,EAAYD,EAAKd,EAAKQ,EAAKN,IACxC,MACGO,EAAIT,GAAMa,EAAYC,EAAKd,EAAKG,EAAMK,KAEvC,OAAOC,CACP,CAED,GAAKF,EAhFY,WAgFO,CAUvB,GANAF,EAAIM,EADJJ,KAASS,IADAT,GAAMU,EA5EiB,KA4EgDC,IAIhFV,EAAKR,EAAKQ,EAAKH,IACfE,EAAKG,EAASF,IAGJZ,EAGRa,EADIF,EAAKV,EACI,IAAPU,EAAaJ,EAAMU,EAAYC,EAAKd,EAAKQ,IAE3CO,EAAYD,EAAKd,EAAKE,EAAOM,SAE5B,GAAKD,EAAKT,EAAqB,CACrC,GAAKS,IAAOX,EACX,OAAOK,EAERQ,EAAIT,GAAMe,EAAYD,EAAKd,EAAKQ,EAAKN,IACxC,MACGO,EAAIT,GAAMa,EAAYC,EAAKd,EAAKG,EAAMK,KAGvC,OAAc,EADTW,EAAiBd,IACDI,EAAIA,CACzB,CAED,OAAKF,GAAMa,EACHC,IAGHd,EA9GY,YA+GF,EAALA,EAAWR,EAGdI,CACR"}